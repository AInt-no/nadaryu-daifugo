<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç™„É≥„É©„Ç§„É≥ÂØæÊà¶ Â§ßÂØåË±™</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap');
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #f0f2f5;
        }
        .card {
            width: 80px;
            height: 120px;
            border: 1px solid #999;
            border-radius: 8px;
            background-color: white;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 4px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            user-select: none;
            position: relative;
            flex-shrink: 0;
        }
        .card.selected {
            transform: translateY(-20px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        .card.joker {
            background-color: #fde047;
        }
        .card .suit-top, .card .suit-bottom {
            font-size: 1.2rem;
            line-height: 1;
        }
        .card .suit-bottom {
            transform: rotate(180deg);
        }
        .card .number {
            font-size: 1.8rem;
            font-weight: bold;
            text-align: center;
        }
        .card.red { color: #ef4444; }
        .card.black { color: #1f2937; }
        
        .player-hand {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 10px 40px 20px 40px;
            min-height: 170px;
        }
        .player-hand .card {
            margin-left: -40px;
        }
        .player-hand .card:first-child {
            margin-left: 0;
        }
        .field-cards {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 140px;
            gap: 8px;
        }
        .player-info {
            transition: all 0.3s ease;
            transform: scale(1);
            width: 8rem; /* 128px */
        }
        .player-info.current-turn {
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
            transform: scale(1.05);
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .selection-hand, .card-display-area {
             display: flex;
             justify-content: center;
             flex-wrap: wrap;
             gap: 8px;
             margin-top: 1rem;
             margin-bottom: 1.5rem;
             max-height: 320px;
             overflow-y: auto;
             padding: 1rem;
             background-color: rgba(0,0,0,0.05);
             border-radius: 8px;
        }
        .selection-hand .card {
            margin-left: 0;
        }
        .selection-hand .card.selected {
             transform: translateY(-10px);
             border: 2px solid #3b82f6;
        }
        .card-display-area .card {
             margin-left: -20px;
        }
        .card-display-area .card:first-child {
             margin-left: 0;
        }
        .designated-suit {
            position: absolute;
            top: 5px;
            right: 8px;
            font-size: 1rem;
            font-weight: bold;
            opacity: 0.7;
        }
        .suit-button {
            font-size: 2rem;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid #ccc;
            background-color: #fff;
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .suit-button:hover:not(:disabled) {
            transform: scale(1.1);
            border-color: #3b82f6;
        }
        .suit-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }


        #reload-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 48px;
            height: 48px;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            font-size: 1.6rem;
            line-height: 1;
            cursor: pointer;
            z-index: 1100;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
        }
        #reload-btn:hover {
            background-color: rgba(255, 255, 255, 0.4);
            transform: rotate(90deg);
        }

        #leave-game-btn {
            position: fixed;
            top: 15px;
            left: 15px;
            background-color: rgba(239, 68, 68, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            z-index: 1100;
            padding: 10px 16px;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
        }
        #leave-game-btn:hover {
            background-color: rgba(220, 38, 38, 0.9);
        }
    </style>
</head>
<body class="bg-green-800 text-white">

    <div id="app" class="container mx-auto p-4 max-w-7xl">

        <button id="reload-btn" onclick="location.reload()" title="„Éö„Éº„Ç∏„ÇíÊõ¥Êñ∞">üîÑ</button>
        <button id="leave-game-btn" class="hidden">ÈÄÄÂá∫</button>

        <div id="home-screen" class="text-center py-12">
            <h1 class="text-5xl font-bold mb-4 text-yellow-300">„Ç™„É≥„É©„Ç§„É≥Â§ßÂØåË±™</h1>
            <p class="mb-8 text-lg">„É´„Éº„É†„Çí‰ΩúÊàê„Åô„Çã„Åã„ÄÅID„ÇíÂÖ•Âäõ„Åó„Å¶ÂèÇÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
            <div class="max-w-md mx-auto bg-white/10 p-8 rounded-lg shadow-lg backdrop-blur-sm">
                <div class="mb-6">
                    <label for="player-name" class="block mb-2 text-sm font-bold">„Éó„É¨„Ç§„É§„ÉºÂêç</label>
                    <input type="text" id="player-name" class="w-full px-4 py-2 rounded-md text-gray-800" placeholder="ÂêçÂâç„ÇíÂÖ•Âäõ">
                </div>
                <button id="create-room-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-gray-800 font-bold py-3 px-4 rounded-lg text-lg transition duration-300 mb-4">„É´„Éº„É†„Çí‰ΩúÊàê„Åô„Çã</button>
                <div class="flex items-center">
                    <input type="text" id="room-id-input" class="w-full px-4 py-2 rounded-l-md text-gray-800" placeholder="„É´„Éº„É†ID„ÇíÂÖ•Âäõ">
                    <button id="join-room-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-r-lg transition duration-300">ÂèÇÂä†</button>
                </div>
            </div>
        </div>
        <div id="lobby-screen" class="hidden">
            <h2 class="text-3xl font-bold text-center mb-4">ÂæÖÊ©ü„É´„Éº„É†</h2>
            <div class="text-center mb-6">
                <p class="text-lg">„É´„Éº„É†ID: <span id="room-id-display" class="font-bold text-2xl text-yellow-300 bg-black/20 px-3 py-1 rounded-md cursor-pointer" onclick="copyRoomId()"></span></p>
                <p class="text-sm text-gray-300">Ôºà„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ID„Çí„Ç≥„Éî„ÉºÔºâ</p>
            </div>
            <div class="bg-white/10 p-6 rounded-lg shadow-lg">
                <h3 class="text-xl font-bold mb-4">ÂèÇÂä†„Éó„É¨„Ç§„É§„Éº</h3>
                <ul id="player-list" class="space-y-2"></ul>
            </div>
            <div class="text-center mt-8">
                <button id="start-game-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-4 px-8 rounded-lg text-xl transition duration-300 shadow-lg disabled:bg-gray-500 disabled:cursor-not-allowed">„Ç≤„Éº„É†ÈñãÂßã (2‰∫∫‰ª•‰∏ä„ÅßÂèØËÉΩ)</button>
            </div>
        </div>
        <div id="game-screen" class="hidden">
            <div id="other-players-container" class="flex justify-around mb-4"></div>
            <div class="bg-green-900/50 min-h-[220px] rounded-lg p-4 mb-4 border-2 border-yellow-400/50">
                <div class="text-center mb-2">
                    <p class="text-sm">Â†¥„Å´Âá∫„Å¶„ÅÑ„Çã„Ç´„Éº„Éâ</p>
                    <div id="game-info" class="text-sm text-yellow-300 h-5"></div>
                </div>
                <div id="field" class="field-cards"></div>
            </div>
            <div class="fixed bottom-0 left-0 right-0 bg-black/30 backdrop-blur-sm p-4">
                <div id="my-hand" class="player-hand mb-4"></div>
                <div id="action-buttons" class="flex justify-center items-center gap-4">
                    <button id="play-card-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg text-lg transition duration-300 disabled:bg-gray-500">Âá∫„Åô</button>
                    <button id="pass-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg text-lg transition duration-300 disabled:bg-gray-500">„Éë„Çπ</button>
                    <button id="dobon-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg text-lg transition duration-300 disabled:bg-gray-500">„Éâ„Éú„É≥ÔºÅ</button>
                </div>
            </div>
        </div>
        <div id="game-over-modal" class="hidden modal-overlay">
            <div class="modal-content bg-gray-800 text-white w-full max-w-md">
                <h2 id="game-over-title" class="text-3xl font-bold mb-4 text-yellow-300">„Ç≤„Éº„É†ÁµÇ‰∫ÜÔºÅ</h2>
                <div id="rankings-list" class="text-left space-y-2 mb-6"></div>
                <button id="next-game-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">Ê¨°„ÅÆ„Ç≤„Éº„É†„Å∏</button>
                <button id="leave-room-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded ml-2">ÈÄÄÂá∫</button>
            </div>
        </div>
        <div id="message-modal" class="hidden modal-overlay">
            <div id="message-content" class="modal-content bg-gray-800 text-white"></div>
        </div>
        <div id="selection-modal" class="hidden modal-overlay">
            <div class="modal-content bg-gray-800 text-white w-full max-w-2xl">
                <h2 id="selection-title" class="text-2xl font-bold mb-2"></h2>
                <p id="selection-description" class="mb-4"></p>
                <div id="selection-hand" class="selection-hand"></div>
                <button id="confirm-selection-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg disabled:bg-gray-500 disabled:cursor-not-allowed">Ê±∫ÂÆö</button>
            </div>
        </div>
        <div id="8giri-modal" class="hidden modal-overlay">
            <div class="modal-content bg-gray-800 text-white w-full max-w-md">
                <h2 class="text-2xl font-bold mb-2">8Âàá„Çä</h2>
                <p class="mb-6">‰ªñ„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅÆ„Éâ„Éú„É≥ÂÆ£Ë®Ä„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...</p>
                <button id="confirm-8giri-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">OK (Â†¥„ÇíÊµÅ„Åô)</button>
            </div>
        </div>
        <div id="5skip-modal" class="hidden modal-overlay">
            <div class="modal-content bg-gray-800 text-white w-full max-w-md">
                <h2 class="text-2xl font-bold mb-2">5„Çπ„Ç≠„ÉÉ„Éó</h2>
                <p class="mb-6">‰ªñ„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅÆ„Éâ„Éú„É≥ÂÆ£Ë®Ä„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...</p>
                <button id="confirm-5skip-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">OK („Çπ„Ç≠„ÉÉ„ÉóÂÆüË°å)</button>
            </div>
        </div>
        <div id="received-cards-modal" class="hidden modal-overlay">
            <div class="modal-content bg-gray-800 text-white w-full max-w-lg">
                <h2 id="received-cards-title" class="text-2xl font-bold mb-4"></h2>
                <div id="received-cards-container" class="flex justify-center flex-wrap gap-2 mb-6"></div>
                <button id="received-cards-ok-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">OK</button>
            </div>
        </div>
        <div id="dobon-success-modal" class="hidden modal-overlay">
            <div class="modal-content bg-yellow-300 text-black w-full max-w-2xl">
                <h2 class="text-5xl font-bold mb-4 text-purple-700">„Éâ„Éú„É≥ÔºÅ</h2>
                <div id="dobon-player-info" class="mb-4 text-lg font-semibold"></div>
                <div id="dobon-hand-container" class="card-display-area"></div>
                <div class="my-6 border-t-2 border-gray-400"></div>
                <p class="text-lg font-semibold">Â†¥„ÅÆ„Ç´„Éº„Éâ</p>
                <div id="dobon-field-container" class="card-display-area"></div>
                <div class="mt-8">
                    <button id="dobon-continue-btn" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg text-lg">„Ç≤„Éº„É†„Å´Êàª„Çã</button>
                    <p id="dobon-wait-message" class="hidden text-gray-700">Ê¨°„ÅÆ„Éó„É¨„Ç§„É§„Éº„Åå„Ç≤„Éº„É†„Å´Êàª„Çã„ÅÆ„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...</p>
                </div>
            </div>
        </div>
        <div id="joker-suit-modal" class="hidden modal-overlay">
            <div class="modal-content bg-gray-800 text-white w-full max-w-md">
                <h2 class="text-2xl font-bold mb-4">„Ç∏„Éß„Éº„Ç´„Éº„ÅÆ„Çπ„Éº„Éà„ÇíÈÅ∏Êäû</h2>
                <p class="mb-6">„Ç∏„Éß„Éº„Ç´„Éº„Çí„Å©„ÅÆ„Çπ„Éº„Éà„Å®„Åó„Å¶Êâ±„ÅÑ„Åæ„Åô„ÅãÔºü</p>
                <div id="joker-suit-buttons" class="flex justify-center gap-4">
                    <button class="suit-button text-gray-800" data-suit="S">‚ô†</button>
                    <button class="suit-button text-red-500" data-suit="H">‚ô•</button>
                    <button class="suit-button text-red-500" data-suit="D">‚ô¶</button>
                    <button class="suit-button text-gray-800" data-suit="C">‚ô£</button>
                </div>
            </div>
        </div>
    </div>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAduXdqwj7aeFAN9sHajCEsX0BDcUWHSv4",
            authDomain: "dai-fugo.firebaseapp.com",
            projectId: "dai-fugo",
            storageBucket: "dai-fugo.firebasestorage.app",
            messagingSenderId: "83747675254",
            appId: "1:83747675254:web:652d8bed0fe1ce045f5357",
            measurementId: "G-B1338R181P"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        const appId = firebaseConfig.projectId;
        let currentUser = null;
        let currentRoomId = null;
        let unsubscribeRoom = null;
        let selectedCards = [];
        let cardsForSelection = [];
        let localGameState = {};
        let acknowledgedEventTimestamp = null;

        const SUITS = ['S', 'H', 'D', 'C'];
        const NUMBERS = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1, 2];
        const JOKER = { suit: 'JOKER', number: 99, id: 'JOKER' };

        const homeScreen = document.getElementById('home-screen');
        const lobbyScreen = document.getElementById('lobby-screen');
        const gameScreen = document.getElementById('game-screen');
        const gameOverModal = document.getElementById('game-over-modal');
        const selectionModal = document.getElementById('selection-modal');
        const eightGiriModal = document.getElementById('8giri-modal');
        const fiveSkipModal = document.getElementById('5skip-modal');
        const receivedCardsModal = document.getElementById('received-cards-modal');
        const dobonSuccessModal = document.getElementById('dobon-success-modal');
        const jokerSuitModal = document.getElementById('joker-suit-modal');
        const leaveGameBtn = document.getElementById('leave-game-btn');

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                const savedRoomId = sessionStorage.getItem('daifugoRoomId');
                if (savedRoomId && !currentRoomId) {
                    await rejoinRoom(savedRoomId);
                }
            } else {
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("ÂåøÂêçË™çË®º„Ç®„É©„Éº:", error);
                    showMessage("Ë™çË®º„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
                }
            }
        });

        function showScreen(screen) {
            homeScreen.classList.add('hidden');
            lobbyScreen.classList.add('hidden');
            gameScreen.classList.add('hidden');
            gameOverModal.classList.add('hidden');
            screen.classList.remove('hidden');
        }

        function showMessage(message, duration = 3000) {
            const modal = document.getElementById('message-modal');
            const content = document.getElementById('message-content');
            content.textContent = message;
            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.add('hidden'), duration);
        }

        function copyRoomId() {
            const roomId = document.getElementById('room-id-display').textContent;

            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(roomId).then(() => {
                    showMessage('„É´„Éº„É†ID„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ');
                }).catch(err => {
                    fallbackCopyTextToClipboard(roomId);
                });
            } else {
                fallbackCopyTextToClipboard(roomId);
            }
        }

        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.top = '-9999px';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage('„É´„Éº„É†ID„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ');
                } else {
                    showMessage('„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
                }
            } catch (err) {
                showMessage('„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
            }
            document.body.removeChild(textArea);
        }

        async function createRoom() {
            if (!currentUser) return showMessage("Ë™çË®ºÊÉÖÂ†±„ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„ÄÇ");
            const playerName = document.getElementById('player-name').value.trim() || `„Éó„É¨„Ç§„É§„Éº${Math.floor(Math.random() * 1000)}`;
            const roomId = Math.random().toString(36).substring(2, 7).toUpperCase();
            
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, roomId);
            const newRoom = {
                roomId: roomId,
                hostId: currentUser.uid,
                players: [{ id: currentUser.uid, name: playerName, isReady: false, rank: null, cardCount: 0 }],
                gameState: { status: 'waiting' },
                createdAt: new Date()
            };

            try {
                await setDoc(roomRef, newRoom);
                currentRoomId = roomId;
                sessionStorage.setItem('daifugoRoomId', roomId);
                listenToRoomChanges(roomId);
            } catch (error) {
                console.error("„É´„Éº„É†‰ΩúÊàê„Ç®„É©„Éº:", error);
                showMessage("„É´„Éº„É†„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
            }
        }

        async function joinRoom() {
            if (!currentUser) return showMessage("Ë™çË®ºÊÉÖÂ†±„ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„ÄÇ");
            const roomId = document.getElementById('room-id-input').value.trim().toUpperCase();
            if (!roomId) return showMessage("„É´„Éº„É†ID„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
            const playerName = document.getElementById('player-name').value.trim() || `„Éó„É¨„Ç§„É§„Éº${Math.floor(Math.random() * 1000)}`;
            
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, roomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("„É´„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ");
                    const roomData = roomDoc.data();
                    if (roomData.gameState.status !== 'waiting') throw new Error("„Ç≤„Éº„É†„ÅØÊó¢„Å´ÈñãÂßã„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ");

                    if (!roomData.players.find(p => p.id === currentUser.uid)) {
                        if (roomData.players.length >= 6) {
                            throw new Error("„Åì„ÅÆ„É´„Éº„É†„ÅØÊ∫ÄÂì°„Åß„Åô„ÄÇ");
                        }
                        const newPlayer = { id: currentUser.uid, name: playerName, isReady: false, rank: null, cardCount: 0 };
                        transaction.update(roomRef, { players: [...roomData.players, newPlayer] });
                    }
                });
                currentRoomId = roomId;
                sessionStorage.setItem('daifugoRoomId', roomId);
                listenToRoomChanges(roomId);
            } catch (error) {
                console.error("„É´„Éº„É†ÂèÇÂä†„Ç®„É©„Éº:", error);
                showMessage(error.message);
                currentRoomId = null;
            }
        }

        async function rejoinRoom(roomId) {
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, roomId);
            try {
                const roomDoc = await getDoc(roomRef);
                if (!roomDoc.exists() || !roomDoc.data().players.some(p => p.id === currentUser.uid)) {
                    cleanupClientState();
                    return;
                }
                currentRoomId = roomId;
                listenToRoomChanges(roomId);
            } catch (error) {
                console.error("ÂÜçÊé•Á∂ö„Ç®„É©„Éº:", error);
                cleanupClientState();
            }
        }
        
        function cleanupClientState() {
            sessionStorage.removeItem('daifugoRoomId');
            if (unsubscribeRoom) unsubscribeRoom();
            unsubscribeRoom = null;
            currentRoomId = null;
            localGameState = {};
            showScreen(homeScreen);
            leaveGameBtn.classList.add('hidden');
        }

        function confirmAndLeave() {
            if (confirm("Êú¨ÂΩì„Å´„É´„Éº„É†„Åã„ÇâÈÄÄÂá∫„Åó„Åæ„Åô„ÅãÔºü")) {
                handleLeaveGame();
            }
        }

        async function handleLeaveGame() {
            if (!currentRoomId || !currentUser) return cleanupClientState();

            const roomId = currentRoomId;
            const userId = currentUser.uid;
            
            cleanupClientState();

            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, roomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) return;

                    let roomData = roomDoc.data();
                    let gameState = roomData.gameState;
                    
                    const leavingPlayer = roomData.players.find(p => p.id === userId);
                    if (!leavingPlayer) return;

                    let remainingPlayers = roomData.players.filter(p => p.id !== userId);

                    if (remainingPlayers.length === 0) {
                        transaction.delete(roomRef);
                        return;
                    }

                    if (gameState.status !== 'waiting') {
                        const leavingPlayerHand = shuffle(gameState.hands?.[userId] || []);
                        if(gameState.hands) delete gameState.hands[userId];

                        if (leavingPlayerHand.length > 0 && remainingPlayers.length > 0) {
                            leavingPlayerHand.forEach((card, index) => {
                                const recipientPlayer = remainingPlayers[index % remainingPlayers.length];
                                if (gameState.hands[recipientPlayer.id]) {
                                     gameState.hands[recipientPlayer.id].push(card);
                                }
                            });
                        }
                        
                        remainingPlayers.forEach(p => {
                           if(gameState.hands[p.id]) {
                               gameState.hands[p.id].sort((a,b) => getCardStrength(a, gameState.isRevolution, gameState.isElevenBack));
                               p.cardCount = gameState.hands[p.id].length;
                           }
                        });
                        
                        gameState.playOrder = gameState.playOrder.filter(id => id !== userId);
                        if (gameState.currentPlayerId === userId) {
                            gameState.currentPlayerId = getNextPlayerId(gameState);
                        }

                        const activePlayers = remainingPlayers.filter(p => !gameState.rankings.includes(p.id));
                        if (activePlayers.length === 1) {
                            gameState.status = 'finished';
                            const winner = activePlayers[0];
                            gameState.rankings.push(winner.id);
                        }

                    }
                    
                    if (roomData.hostId === userId) {
                        roomData.hostId = remainingPlayers[0].id;
                    }
                    
                    gameState.players = remainingPlayers;
                    
                    transaction.update(roomRef, { 
                        players: remainingPlayers, 
                        hostId: roomData.hostId,
                        gameState: gameState 
                    });
                });
            } catch (error) {
                console.error("„Ç≤„Éº„É†ÈÄÄÂá∫Âá¶ÁêÜ„Ç®„É©„Éº:", error);
            }
        }

        function createDeck() {
            const deck = [];
            SUITS.forEach(suit => {
                NUMBERS.forEach(number => {
                    deck.push({ suit, number, id: `${suit}${number}` });
                });
            });
            deck.push({ ...JOKER, id: 'JOKER1' });
            deck.push({ ...JOKER, id: 'JOKER2' });
            return deck;
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        async function startGame() {
            if (!currentRoomId) return;
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            const roomDoc = await getDoc(roomRef);
            if (!roomDoc.exists()) return;

            const roomData = roomDoc.data();
            const players = roomData.players;
            if (players.length < 2) return showMessage("„Éó„É¨„Ç§„É§„Éº„Åå2‰∫∫‰ª•‰∏äÂøÖË¶Å„Åß„Åô„ÄÇ");
            
            const deck = shuffle(createDeck());
            const hands = {};
            players.forEach(p => { hands[p.id] = []; });

            let playerIndex = 0;
            deck.forEach(card => {
                hands[players[playerIndex].id].push(card);
                playerIndex = (playerIndex + 1) % players.length;
            });
            
            Object.keys(hands).forEach(playerId => {
                hands[playerId].sort((a, b) => getCardStrength(a) - getCardStrength(b));
            });

            const playOrder = players.map(p => p.id);
            let currentPlayerId;
            const lastGameWinner = players.find(p => p.rank === players.length);
            if (lastGameWinner) {
                currentPlayerId = lastGameWinner.id;
            } else {
                const diamond3Player = Object.keys(hands).find(id => hands[id].some(c => c.suit === 'D' && c.number === 3));
                currentPlayerId = diamond3Player || players[0].id;
            }
            
            const updatedPlayers = players.map(p => ({ ...p, cardCount: hands[p.id].length, rank: null }));

            const initialGameState = {
                status: 'playing',
                hands: hands,
                players: updatedPlayers,
                playOrder: playOrder,
                currentPlayerId: currentPlayerId,
                field: { cards: [], lastPlayerId: null, suitLock: null },
                passCount: 0,
                isRevolution: false,
                isElevenBack: false,
                lastActionTimestamp: new Date(),
                rankings: [],
                log: [`„Ç≤„Éº„É†ÈñãÂßãÔºÅ ${players.find(p=>p.id === currentPlayerId).name}„Åï„Çì„Åã„Çâ„Çπ„Çø„Éº„Éà„Åß„Åô„ÄÇ`]
            };

            await updateDoc(roomRef, { gameState: initialGameState, players: updatedPlayers });
        }
        
        async function playCards() {
            if (selectedCards.length === 0) return;
            
            const hasJoker = selectedCards.some(c => c.suit === 'JOKER');
            const hasNumberCard = selectedCards.some(c => c.suit !== 'JOKER');

            if (hasJoker && hasNumberCard) {
                promptJokerSuit();
            } else {
                executePlay(selectedCards);
            }
        }

        async function executePlay(cardsToPlay) {
            const { hands, currentPlayerId, field, isRevolution, isElevenBack } = localGameState;
            if (currentUser.uid !== currentPlayerId) return showMessage("„ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ");
            
            const validation = isValidPlay(cardsToPlay, field, isRevolution, isElevenBack);
            if (!validation.valid) return showMessage(validation.message);

            const myHand = hands[currentUser.uid];
            if (myHand.length === cardsToPlay.length) {
                const lastCard = cardsToPlay.find(c => c.suit !== 'JOKER') || cardsToPlay[0];
                const strongestCardNumber = isRevolution ? 3 : 2;
                if (lastCard.suit === 'JOKER' || lastCard.number === strongestCardNumber) {
                    return showMessage("ÂèçÂâá„ÅÇ„Åå„Çä„Åß„ÅôÔºÅ„Ç∏„Éß„Éº„Ç´„Éº„ÇÑÊúÄÂº∑„ÅÆ„Ç´„Éº„Éâ(2„Åæ„Åü„ÅØ3)„Åß„ÅØ„ÅÇ„Åå„Çå„Åæ„Åõ„Çì„ÄÇ");
                }
            }

            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("„É´„Éº„É†„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ");
                    
                    let newGameState = { ...roomDoc.data().gameState };
                    if (newGameState.currentPlayerId !== currentUser.uid) throw new Error("„Çø„Éº„É≥„ÅåÂ§â„Çè„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ");
                    
                    const newHand = newGameState.hands[currentUser.uid].filter(card => !cardsToPlay.find(sc => sc.id === card.id));
                    const playedCardNumber = (cardsToPlay.find(c => c.suit !== 'JOKER') || cardsToPlay[0]).number;
                    const playedCardCount = cardsToPlay.length;
                    const player = newGameState.players.find(p => p.id === currentUser.uid);
                    let playerHasFinished = false;
                    
                    // „Äê‰øÆÊ≠£„Äë7Ê∏°„Åó„Åß„ÅÆ„ÅÇ„Åå„ÇäÂà§ÂÆö„Å®ÊâãÊú≠Êõ¥Êñ∞„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ„Çí‰øÆÊ≠£
                    if (playedCardNumber === 7 && newHand.length > 0 && newHand.length <= playedCardCount) {
                        playerHasFinished = true;
                        const nextPlayerId = getNextPlayerId(newGameState);
                        if(newGameState.hands[nextPlayerId]) {
                            newGameState.hands[nextPlayerId].push(...newHand);
                            newGameState.hands[nextPlayerId].sort((a,b)=>getCardStrength(a, newGameState.isRevolution, newGameState.isElevenBack));
                        }
                        newGameState.hands[currentUser.uid] = []; // Ê∏°„Åô„ÅÆ„ÅßÊâãÊú≠„ÅØÁ©∫„Å´„Å™„Çã
                        newGameState.log.push(`${player.name}„Åï„Çì„Åå7Ê∏°„Åó„ÅßÊâãÊú≠„ÇíÂÖ®„Å¶Ê∏°„Åó„ÄÅ„ÅÇ„Åå„Çä„Åæ„Åó„ÅüÔºÅ`);
                    } else if (newHand.length === 0) {
                        playerHasFinished = true;
                        newGameState.hands[currentUser.uid] = []; // ÊúÄÂæå„ÅÆ„Ç´„Éº„Éâ„ÇíÂá∫„Åó„Åü„ÅÆ„ÅßÊâãÊú≠„ÅØÁ©∫
                        newGameState.log.push(`${player.name}„Åï„Çì„Åå„ÅÇ„Åå„Çä„Åæ„Åó„ÅüÔºÅ`);
                    } else {
                        newGameState.hands[currentUser.uid] = newHand; // ÈÄöÂ∏∏„ÅØÊâãÊú≠„ÇíÊõ¥Êñ∞
                    }

                    if(playerHasFinished) {
                        newGameState.rankings.push(currentUser.uid);
                    }
                    newGameState.players = newGameState.players.map(p => ({...p, cardCount: newGameState.hands[p.id]?.length || 0 }));
                    
                    if (playerHasFinished) {
                        newGameState.field = { cards: [], lastPlayerId: null, suitLock: null };
                        newGameState.passCount = 0;
                        newGameState.currentPlayerId = getNextPlayerId(newGameState);
                        newGameState.log.push("Â†¥„ÅåÊµÅ„Çå„Åæ„Åô„ÄÇ");
                    } else if (playedCardNumber === 8) {
                        newGameState.status = 'awaiting_8giri_confirmation';
                        newGameState.pendingAction = { type: '8-giri', playerId: currentUser.uid };
                        newGameState.field = { cards: cardsToPlay, lastPlayerId: currentUser.uid, suitLock: validation.newSuitLock };
                        newGameState.passCount = 0;
                    } else if (playedCardNumber === 5) {
                        newGameState.status = 'awaiting_5skip_confirmation';
                        newGameState.pendingAction = { type: '5-skip', playerId: currentUser.uid, count: playedCardCount };
                        newGameState.field = { cards: cardsToPlay, lastPlayerId: currentUser.uid, suitLock: validation.newSuitLock };
                        newGameState.passCount = 0;
                    } else if (playedCardNumber === 7 || playedCardNumber === 10) {
                        newGameState.status = 'awaiting_selection';
                        newGameState.pendingAction = {
                            type: playedCardNumber === 7 ? '7-pass' : '10-discard',
                            playerId: currentUser.uid,
                            count: playedCardCount
                        };
                        newGameState.field = { cards: cardsToPlay, lastPlayerId: currentUser.uid, suitLock: validation.newSuitLock };
                        newGameState.passCount = 0;
                        newGameState.log.push(`${player.name}„Åï„Çì„Åå${playedCardNumber}„Çí${playedCardCount}ÊûöÂá∫„Åó„Åæ„Åó„Åü„ÄÇ`);
                    } else {
                        const effectResult = handleSpecialCards(cardsToPlay, newGameState);
                        newGameState = effectResult.newGameState;
                        
                        newGameState.field = { cards: cardsToPlay, lastPlayerId: currentUser.uid, suitLock: validation.newSuitLock };
                        newGameState.passCount = 0;
                        if (!effectResult.skipTurn) {
                            newGameState.currentPlayerId = getNextPlayerId(newGameState);
                        }
                    }
                    
                    newGameState.lastActionTimestamp = new Date();
                    
                    const activePlayersCount = newGameState.players.filter(p => !newGameState.rankings.includes(p.id)).length;
                    if (activePlayersCount <= 1) {
                        const lastPlayer = newGameState.players.find(p => !newGameState.rankings.includes(p.id));
                        if(lastPlayer && !newGameState.rankings.includes(lastPlayer.id)) {
                            newGameState.rankings.push(lastPlayer.id);
                        }
                        newGameState.status = 'finished';
                    }

                    transaction.update(roomRef, { gameState: newGameState });
                });
                selectedCards = [];
            } catch (error) {
                console.error("„Ç´„Éº„ÉâÊèêÂá∫„Ç®„É©„Éº:", error);
                showMessage(error.message);
            }
        }
        
        async function passTurn() {
             const { currentPlayerId } = localGameState;
            if (currentUser.uid !== currentPlayerId) return showMessage("„ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ");

            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("„É´„Éº„É†„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ");
                    
                    let gameState = roomDoc.data().gameState;
                    if (gameState.currentPlayerId !== currentUser.uid) throw new Error("„Çø„Éº„É≥„ÅåÂ§â„Çè„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ");
                    
                    gameState.passCount += 1;
                    const activePlayersCount = gameState.players.filter(p => p.cardCount > 0 && !gameState.rankings.includes(p.id)).length;

                    if (gameState.passCount >= activePlayersCount - 1 && gameState.field.lastPlayerId) {
                        gameState.currentPlayerId = gameState.field.lastPlayerId;
                        gameState.field = { cards: [], lastPlayerId: null, suitLock: null };
                        gameState.passCount = 0;
                        gameState.log.push("Â†¥„ÅåÊµÅ„Çå„Åæ„Åó„Åü„ÄÇ");
                        if (gameState.isElevenBack) {
                            gameState.isElevenBack = false;
                            gameState.log.push("„Ç§„É¨„Éñ„É≥„Éê„ÉÉ„ÇØ„ÅÆÂäπÊûú„ÅåÂàá„Çå„Åæ„Åó„Åü„ÄÇ");
                        }
                    } else {
                        gameState.currentPlayerId = getNextPlayerId(gameState);
                    }
                    
                    gameState.lastActionTimestamp = new Date();
                    transaction.update(roomRef, { gameState });
                });
            } catch (error) {
                console.error("„Éë„Çπ„Ç®„É©„Éº:", error);
                showMessage(error.message);
            }
        }

        async function declareDobon() {
            const { hands, field } = localGameState;
            const myHand = hands[currentUser.uid];
            
            if (myHand.length < 2) return showMessage("„Éâ„Éú„É≥„ÅØÊâãÊú≠„Åå2Êûö‰ª•‰∏ä„Å™„ÅÑ„Å®ÂÆ£Ë®Ä„Åß„Åç„Åæ„Åõ„Çì„ÄÇ");
            if (field.lastPlayerId === currentUser.uid) return showMessage("Ëá™ÂàÜ„ÅåÂá∫„Åó„Åü„Ç´„Éº„Éâ„Åß„Éâ„Éú„É≥„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ");
            if (!field.cards || field.cards.length === 0) return showMessage("Â†¥„Å´„Ç´„Éº„Éâ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ");

            const handSum = myHand.reduce((sum, card) => sum + getDobonValue(card), 0);
            const fieldSum = field.cards.reduce((sum, card) => sum + getDobonValue(card), 0);

            if (handSum !== fieldSum) {
                return showMessage(`„Éâ„Éú„É≥Â§±ÊïóÔºÅ ÊâãÊú≠ÂêàË®à: ${handSum}, Â†¥„ÅÆÂêàË®à: ${fieldSum}`);
            }
            
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("„É´„Éº„É†„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ");
                    
                    let gameState = roomDoc.data().gameState;
                    const winnerPlayer = gameState.players.find(p => p.id === currentUser.uid);
                    
                    gameState.status = 'awaiting_dobon_acknowledgement';
                    gameState.rankings.push(currentUser.uid);
                    
                    const nextPlayerId = getNextPlayerId(gameState);

                    gameState.dobonInfo = {
                        playerName: winnerPlayer.name,
                        playerHand: gameState.hands[currentUser.uid],
                        fieldCards: gameState.field.cards,
                        sum: handSum,
                        nextPlayerId: nextPlayerId
                    };
                    
                    gameState.log.push(`üéâ ${winnerPlayer.name}„Åï„Çì„Åå„Éâ„Éú„É≥„Åß„ÅÇ„Åå„Çä„Åæ„Åó„ÅüÔºÅ`);
                    transaction.update(roomRef, { gameState });
                });
            } catch (error) {
                console.error("„Éâ„Éú„É≥Âá¶ÁêÜ„Ç®„É©„Éº:", error);
                showMessage(error.message);
            }
        }

        function handleSpecialCards(playedCards, gameState) {
            const player = gameState.players.find(p => p.id === gameState.currentPlayerId);
            const nonJokers = playedCards.filter(c => c.suit !== 'JOKER');
            const uniqueNumbers = [...new Set(nonJokers.map(c => c.number))];
            const cardNum = uniqueNumbers[0] || (playedCards.find(c => c.suit === 'JOKER') ? playedCards[0].number : null);
            const cardCount = playedCards.length;
            
            const isFourCardRevolution = (cardCount === 4 && uniqueNumbers.length <= 1);
            const isThreeThreesRevolution = (cardCount === 3 && nonJokers.length === 3 && cardNum === 3);

            if (isFourCardRevolution || isThreeThreesRevolution) {
                gameState.isRevolution = !gameState.isRevolution;
                gameState.log.push(`${player.name}„Åï„Çì„ÅåÈù©ÂëΩ„ÇíËµ∑„Åì„Åó„Åæ„Åó„ÅüÔºÅ`);
            }
            
            if (cardNum === 11 && cardCount % 2 !== 0) {
                gameState.isElevenBack = !gameState.isElevenBack;
                gameState.log.push(`${player.name}„Åï„Çì„Åå„Ç§„É¨„Éñ„É≥„Éê„ÉÉ„ÇØÔºÅ`);
            }
            
            return { newGameState: gameState, fieldCleared: false, skipTurn: false };
        }

        function getCardStrength(card, isRevolution = false, isElevenBack = false) {
            if (card.suit === 'JOKER') return 999;
            const revolutionActive = isRevolution !== isElevenBack;
            let strength = card.number;
            if (strength === 1) strength = 14;
            if (strength === 2) strength = 15;
            if (revolutionActive) {
                if (strength === 3) return 16;
                return 15 - (strength - 3);
            }
            return strength;
        }

        function getDobonValue(card) {
            if (card.suit === 'JOKER') return 0;
            return card.number;
        }
        
        function getNextPlayerId(gameState) {
            const { playOrder, currentPlayerId, rankings } = gameState;
            let currentIndex = playOrder.indexOf(currentPlayerId);
            if (currentIndex === -1) return playOrder.find(pId => !rankings.includes(pId));
            let nextPlayerId;
            let count = 0;
            do {
                currentIndex = (currentIndex + 1) % playOrder.length;
                nextPlayerId = playOrder[currentIndex];
                count++;
            } while (rankings.includes(nextPlayerId) && count < playOrder.length * 2);
            return nextPlayerId;
        }

        function isValidPlay(playedCards, field, isRevolution, isElevenBack) {
            if (playedCards.length === 0) return { valid: false, message: "„Ç´„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ" };

            const playIsJoker = playedCards.length === 1 && playedCards[0].suit === 'JOKER';
            const playIsSpade3 = playedCards.length === 1 && playedCards[0].suit === 'S' && playedCards[0].number === 3;
            const fieldIsJoker = field.cards.length === 1 && field.cards[0].suit === 'JOKER';
            
            const getCombinedSuits = (cards) => {
                const suits = cards.map(c => c.designatedSuit || c.suit)
                                .filter(s => s !== 'JOKER');
                return [...new Set(suits)].sort().join('');
            };
            
            if (fieldIsJoker && playIsSpade3) return { valid: true, newSuitLock: null };
            
            if (field.cards.length > 0) {
                if (playedCards.length !== field.cards.length) {
                    if (!playIsJoker) {
                        return { valid: false, message: "Â†¥„Å®Âêå„ÅòÊûöÊï∞„ÅÆ„Ç´„Éº„Éâ„ÇíÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ" };
                    }
                }
                
                const playStrength = getCardStrength(playedCards.find(c => c.suit !== 'JOKER') || playedCards[0], isRevolution, isElevenBack);
                const fieldStrength = getCardStrength(field.cards.find(c => c.suit !== 'JOKER') || field.cards[0], isRevolution, isElevenBack);
                
                if (playStrength <= fieldStrength) return { valid: false, message: "Â†¥„Çà„Çä„ÇÇÂº∑„ÅÑ„Ç´„Éº„Éâ„ÇíÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ" };
                
                if (field.suitLock) {
                    const playSuits = getCombinedSuits(playedCards);
                    if (playSuits && field.suitLock !== playSuits) return { valid: false, message: `Á∏õ„Çä„ÅåÁô∫Áîü„Åó„Å¶„ÅÑ„Åæ„ÅôÔºÅ„Çπ„Éº„Éà: [${field.suitLock.split('').join(', ')}]` };
                }
            }
            
            const numbers = playedCards.map(c => c.number).filter(n => n !== 99);
            if ([...new Set(numbers)].length > 1) return { valid: false, message: "Âêå„ÅòÊï∞Â≠ó„ÅÆ„Ç´„Éº„Éâ„Åó„ÅãÂêåÊôÇ„Å´Âá∫„Åõ„Åæ„Åõ„Çì„ÄÇ" };

            let newSuitLock = null;
            if (field.cards.length > 0 && playedCards.length > 1) {
                const lastSuits = getCombinedSuits(field.cards);
                const playSuits = getCombinedSuits(playedCards);
                if (lastSuits === playSuits && playSuits.length > 0) {
                    newSuitLock = playSuits;
                }
            }

            return { valid: true, newSuitLock };
        }

        function listenToRoomChanges(roomId) {
            if (unsubscribeRoom) unsubscribeRoom();

            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, roomId);
            unsubscribeRoom = onSnapshot(roomRef, (doc) => {
                if (!doc.exists()) {
                    showMessage("„É´„Éº„É†„ÅåÂâäÈô§„Åï„Çå„Åæ„Åó„Åü„ÄÇ„Éõ„Éº„É†„Å´Êàª„Çä„Åæ„Åô„ÄÇ");
                    cleanupClientState();
                    return;
                }
                
                const roomData = doc.data();
                localGameState = roomData.gameState || {};
                leaveGameBtn.classList.remove('hidden');
                
                processLastEvent(localGameState);
                
                switch (localGameState.status) {
                    case 'waiting':
                        showScreen(lobbyScreen);
                        updateLobbyUI(roomData);
                        break;
                    
                    case 'playing':
                        dobonSuccessModal.classList.add('hidden');
                        eightGiriModal.classList.add('hidden');
                        fiveSkipModal.classList.add('hidden');
                        if(selectionModal.classList.contains('hidden')) {
                             showScreen(gameScreen);
                             updateGameUI(localGameState);
                        }
                        break;
                        
                    case 'awaiting_selection':
                        showScreen(gameScreen);
                        updateGameUI(localGameState);
                        if (localGameState.pendingAction?.playerId === currentUser.uid) {
                            showSelectionModal(localGameState);
                        }
                        break;
                    
                    case 'awaiting_8giri_confirmation':
                        showScreen(gameScreen);
                        updateGameUI(localGameState);
                         if (localGameState.pendingAction?.playerId === currentUser.uid) {
                            eightGiriModal.classList.remove('hidden');
                        }
                        break;
                    
                    case 'awaiting_5skip_confirmation':
                        showScreen(gameScreen);
                        updateGameUI(localGameState);
                         if (localGameState.pendingAction?.playerId === currentUser.uid) {
                            fiveSkipModal.classList.remove('hidden');
                        }
                        break;
                    
                    case 'awaiting_dobon_acknowledgement':
                        showDobonSuccessModal(localGameState);
                        break;
                        
                    case 'finished':
                        showScreen(gameScreen);
                        updateGameUI(localGameState);
                        showGameOverUI(localGameState);
                        break;
                }
            });
        }
        
        function updateLobbyUI(roomData) {
            document.getElementById('room-id-display').textContent = roomData.roomId;
            const playerList = document.getElementById('player-list');
            playerList.innerHTML = '';
            roomData.players.forEach(player => {
                const li = document.createElement('li');
                li.className = 'bg-white/20 p-3 rounded-md flex justify-between items-center';
                li.textContent = player.name + (player.id === roomData.hostId ? ' („Éõ„Çπ„Éà)' : '');
                playerList.appendChild(li);
            });

            const startGameBtn = document.getElementById('start-game-btn');
            if (currentUser && currentUser.uid === roomData.hostId) {
                startGameBtn.disabled = roomData.players.length < 2;
                startGameBtn.classList.remove('hidden');
            } else {
                startGameBtn.classList.add('hidden');
            }
        }

        function updateGameUI(gameState) {
            const { players, hands, currentPlayerId, field, isRevolution, isElevenBack, rankings, status } = gameState || {};
            
            const myHandContainer = document.getElementById('my-hand');
            myHandContainer.innerHTML = '';
            const myHand = (hands && currentUser && hands[currentUser.uid]) ? hands[currentUser.uid] : [];
            
            myHand.sort((a,b) => getCardStrength(a, isRevolution, isElevenBack) - getCardStrength(b, isRevolution, isElevenBack));
            myHand.forEach(card => {
                const cardEl = createCardElement(card);
                cardEl.addEventListener('click', () => toggleCardSelection(card, cardEl));
                if (selectedCards.some(sc => sc.id === card.id)) cardEl.classList.add('selected');
                myHandContainer.appendChild(cardEl);
            });
            
            const otherPlayersContainer = document.getElementById('other-players-container');
            otherPlayersContainer.innerHTML = '';
            if(!players) return;
            const myPlayerIndex = players.findIndex(p => currentUser && p.id === currentUser.uid);
            if (myPlayerIndex === -1) return;

            const orderedPlayers = [...players.slice(myPlayerIndex + 1), ...players.slice(0, myPlayerIndex)];
            
            orderedPlayers.forEach(player => {
                const playerInfoEl = document.createElement('div');
                playerInfoEl.className = 'player-info bg-black/30 p-2 rounded-lg text-center w-32';
                
                if (player.id === currentPlayerId && status === 'playing') {
                    playerInfoEl.classList.add('current-turn');
                }
                
                const rank = rankings.indexOf(player.id);
                const rankText = rank !== -1 ? `<span class="text-yellow-400 font-bold">${getRankName(rank, players.length + rankings.length)}</span>` : '';
                playerInfoEl.innerHTML = `<p class="font-bold truncate">${player.name}</p><p>ÊÆã„Çä: ${player.cardCount}Êûö</p><p>${rankText}</p>`;
                otherPlayersContainer.appendChild(playerInfoEl);
            });

            const fieldContainer = document.getElementById('field');
            fieldContainer.innerHTML = '';
            (field?.cards || []).forEach(card => fieldContainer.appendChild(createCardElement(card)));
            if (!field?.cards || field.cards.length === 0) fieldContainer.innerHTML = `<p class="text-gray-400">„Ç´„Éº„Éâ„ÅåÂá∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì</p>`;

            const gameInfoEl = document.getElementById('game-info');
            let infoText = '';
            if (isRevolution) infoText += '<span class="text-red-500 font-bold">Èù©ÂëΩ‰∏≠</span> ';
            if (isElevenBack) infoText += '<span class="text-blue-400 font-bold">„Ç§„É¨„Éñ„É≥„Éê„ÉÉ„ÇØ‰∏≠</span> ';
            if (field?.suitLock) infoText += `<span class="text-green-400 font-bold">Á∏õ„Çä: ${field.suitLock.split('').join(', ')}</span>`;
            
            gameInfoEl.innerHTML = infoText;

            const actionLocked = status && status.startsWith('awaiting_');
            const isMyTurn = currentPlayerId === currentUser.uid && status === 'playing';

            document.getElementById('play-card-btn').disabled = !isMyTurn || actionLocked;
            document.getElementById('pass-btn').disabled = !isMyTurn || actionLocked || !field?.cards || field.cards.length === 0;
            
            let canDobon = !actionLocked && myHand.length >= 2 && field?.cards?.length > 0 && field.lastPlayerId !== currentUser.uid;
            if (status && status.includes('confirmation') && localGameState.pendingAction?.playerId === currentUser.uid) {
                canDobon = false;
            }
            if (status === 'playing' || (status && status.includes('confirmation'))) {
                 document.getElementById('dobon-btn').disabled = !canDobon;
            } else {
                 document.getElementById('dobon-btn').disabled = true;
            }
        }
        
        function getRankName(rankIndex, totalPlayers) {
            return `${rankIndex + 1}‰Ωç`;
        }

        function showGameOverUI(gameState) {
            if (!gameState || !gameState.rankings || !gameState.players) return;
            gameOverModal.classList.remove('hidden');
            const rankingsList = document.getElementById('rankings-list');
            rankingsList.innerHTML = '';
            
            const totalPlayersInGame = (localGameState.players?.length || 0) + (localGameState.rankings?.length || 0);

            gameState.rankings.forEach((playerId, index) => {
                const player = (localGameState.players || []).find(p => p.id === playerId) || (gameState.players || []).find(p => p.id === playerId);
                if(!player) return;
                const li = document.createElement('div');
                li.className = "flex justify-between items-center p-2 bg-white/10 rounded";
                const rankName = getRankName(index, totalPlayersInGame);
                li.innerHTML = `<span class="font-bold text-yellow-400">${rankName}</span><span>${player.name}</span>`;
                rankingsList.appendChild(li);
            });
            
            const hostId = localGameState.hostId || gameState.hostId;
            document.getElementById('next-game-btn').classList.toggle('hidden', !currentUser || currentUser.uid !== hostId);
        }
        
        function createCardElement(card) {
            const el = document.createElement('div');
            el.className = 'card';
            const suitSymbols = { S: '‚ô†', H: '‚ô•', D: '‚ô¶', C: '‚ô£' };
            
            if (card.suit === 'JOKER') {
                el.classList.add('joker');
                el.innerHTML = `<div class="suit-top">üÉè</div><div class="number">JOKER</div><div class="suit-bottom">üÉè</div>`;
                if (card.designatedSuit) {
                    const suitEl = document.createElement('div');
                    suitEl.className = 'designated-suit';
                    if (card.designatedSuit === 'H' || card.designatedSuit === 'D') {
                        suitEl.classList.add('text-red-500');
                    }
                    suitEl.textContent = suitSymbols[card.designatedSuit];
                    el.appendChild(suitEl);
                }
            } else {
                const suitColors = { S: 'black', H: 'red', D: 'red', C: 'black' };
                const numberDisplay = { 1: 'A', 11: 'J', 12: 'Q', 13: 'K' };
                el.classList.add(suitColors[card.suit]);
                el.innerHTML = `<div class="suit-top">${suitSymbols[card.suit]}</div><div class="number">${numberDisplay[card.number] || card.number}</div><div class="suit-bottom">${suitSymbols[card.suit]}</div>`;
            }
            return el;
        }
        
        function toggleCardSelection(card, element) {
            const index = selectedCards.findIndex(c => c.id === card.id);
            if (index > -1) {
                selectedCards.splice(index, 1);
                element.classList.remove('selected');
            } else {
                selectedCards.push(card);
                element.classList.add('selected');
            }
        }

        function processLastEvent(gameState) {
            if (!gameState || !gameState.lastEvent || gameState.lastEvent.timestamp === acknowledgedEventTimestamp) {
                return;
            }
            acknowledgedEventTimestamp = gameState.lastEvent.timestamp;
            if (gameState.lastEvent.type === '7-pass' && gameState.lastEvent.recipientId === currentUser.uid) {
                showReceivedCardsModal(gameState.lastEvent);
            }
        }

        function showReceivedCardsModal(event) {
            const titleEl = document.getElementById('received-cards-title');
            const containerEl = document.getElementById('received-cards-container');

            titleEl.textContent = `${event.senderName}„Åï„Çì„Åã„Çâ„Ç´„Éº„Éâ„ÇíÂèó„ÅëÂèñ„Çä„Åæ„Åó„Åü`;
            containerEl.innerHTML = '';
            event.cards.forEach(card => {
                containerEl.appendChild(createCardElement(card));
            });
            receivedCardsModal.classList.remove('hidden');
        }

        function showSelectionModal(gameState) {
            const { pendingAction, hands } = gameState;
            if (!pendingAction || !selectionModal.classList.contains('hidden')) return;

            const myHand = hands[currentUser.uid];
            cardsForSelection = [];

            const titleEl = document.getElementById('selection-title');
            const descriptionEl = document.getElementById('selection-description');
            const handContainer = document.getElementById('selection-hand');
            const confirmBtn = document.getElementById('confirm-selection-btn');
            
            titleEl.textContent = pendingAction.type === '7-pass' ? '7Ê∏°„Åó' : '10Êç®„Å¶';
            descriptionEl.textContent = `ÊâãÊú≠„Åã„Çâ${pendingAction.type === '7-pass' ? 'Ê∏°„Åô' : 'Êç®„Å¶„Çã'}„Ç´„Éº„Éâ„Çí ${pendingAction.count}Êûö ÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ`;
            
            handContainer.innerHTML = '';
            myHand.forEach(card => {
                const cardEl = createCardElement(card);
                cardEl.addEventListener('click', () => toggleCardForSelection(card, cardEl, pendingAction.count));
                handContainer.appendChild(cardEl);
            });
            
            confirmBtn.disabled = true;
            selectionModal.classList.remove('hidden');
        }

        function toggleCardForSelection(card, element, maxSelection) {
            const confirmBtn = document.getElementById('confirm-selection-btn');
            const index = cardsForSelection.findIndex(c => c.id === card.id);
            if (index > -1) {
                cardsForSelection.splice(index, 1);
                element.classList.remove('selected');
            } else {
                if (cardsForSelection.length < maxSelection) {
                    cardsForSelection.push(card);
                    element.classList.add('selected');
                }
            }
            confirmBtn.disabled = cardsForSelection.length !== maxSelection;
        }

        async function confirmSelection() {
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            try {
                 await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("„É´„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ");

                    let gameState = roomDoc.data().gameState;
                    const { pendingAction, hands, players } = gameState;

                    if (!pendingAction || pendingAction.playerId !== currentUser.uid) throw new Error("‰∏çÊ≠£„Å™Êìç‰Ωú„Åß„Åô„ÄÇ");
                    if (cardsForSelection.length !== pendingAction.count) throw new Error(`„Ç´„Éº„Éâ„Çí${pendingAction.count}ÊûöÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`);

                    const player = players.find(p => p.id === currentUser.uid);
                    let myNewHand = hands[currentUser.uid].filter(card => !cardsForSelection.find(sc => sc.id === card.id));

                    if (pendingAction.type === '7-pass') {
                        const nextPlayerId = getNextPlayerId(gameState);
                        const nextPlayer = players.find(p => p.id === nextPlayerId);
                        hands[nextPlayerId].push(...cardsForSelection);
                        hands[nextPlayerId].sort((a,b) => getCardStrength(a, gameState.isRevolution, gameState.isElevenBack));
                        gameState.log.push(`${player.name}„Åï„Çì„Åå${nextPlayer.name}„Åï„Çì„Å´„Ç´„Éº„Éâ„Çí${pendingAction.count}ÊûöÊ∏°„Åó„Åæ„Åó„Åü„ÄÇ`);
                        
                        gameState.lastEvent = {
                            type: '7-pass',
                            recipientId: nextPlayerId,
                            senderName: player.name,
                            cards: cardsForSelection,
                            timestamp: new Date().toISOString()
                        };

                    } else {
                        gameState.log.push(`${player.name}„Åï„Çì„Åå„Ç´„Éº„Éâ„Çí${pendingAction.count}ÊûöÊç®„Å¶„Åæ„Åó„Åü„ÄÇ`);
                    }

                    hands[currentUser.uid] = myNewHand;
                    
                    gameState.players = players.map(p => ({...p, cardCount: hands[p.id].length }));
                    gameState.status = 'playing';
                    gameState.currentPlayerId = getNextPlayerId(gameState);
                    delete gameState.pendingAction;

                    transaction.update(roomRef, { gameState });
                 });
                 selectionModal.classList.add('hidden');
                 cardsForSelection = [];
            } catch(error) {
                console.error("ÈÅ∏ÊäûÁ¢∫ÂÆö„Ç®„É©„Éº:", error);
                showMessage(error.message);
            }
        }
        
        async function resolve8giri() {
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("„É´„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ");
                    let gameState = roomDoc.data().gameState;

                    if (gameState.status !== 'awaiting_8giri_confirmation' || gameState.pendingAction?.playerId !== currentUser.uid) {
                        return;
                    }
                    
                    gameState.field = { cards: [], lastPlayerId: null, suitLock: null };
                    gameState.passCount = 0;
                    gameState.currentPlayerId = currentUser.uid;
                    gameState.log.push("8Âàá„Çä„ÅßÂ†¥„ÅåÊµÅ„Çå„Åæ„Åó„Åü„ÄÇ");
                    
                    gameState.status = 'playing';
                    delete gameState.pendingAction;
                    transaction.update(roomRef, { gameState });
                });
                eightGiriModal.classList.add('hidden');
            } catch (error) {
                 console.error("8Âàá„ÇäËß£Ê±∫„Ç®„É©„Éº:", error);
                 showMessage(error.message);
            }
        }

        async function resolve5skip() {
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("„É´„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ");
                    let gameState = roomDoc.data().gameState;

                    if (gameState.status !== 'awaiting_5skip_confirmation' || gameState.pendingAction?.playerId !== currentUser.uid) {
                        return;
                    }

                    const cardCount = gameState.pendingAction.count;
                    const skips = (2 * cardCount) - 1;
                    const activePlayersCount = gameState.players.filter(p => !gameState.rankings.includes(p.id)).length;
                    
                    if (skips >= activePlayersCount - 1) {
                        gameState.field = { cards: [], lastPlayerId: null, suitLock: null };
                        gameState.currentPlayerId = currentUser.uid;
                        gameState.log.push(`5„Åß‰ªñ„ÅÆÂÖ®Âì°„Åå„Çπ„Ç≠„ÉÉ„Éó„Åï„Çå„ÄÅÂ†¥„ÅåÊµÅ„Çå„Åæ„Åó„Åü„ÄÇ`);
                    } else {
                        let lastSkippedPlayerId = currentUser.uid;
                        for (let i = 0; i < skips; i++) {
                            lastSkippedPlayerId = getNextPlayerId({ ...gameState, currentPlayerId: lastSkippedPlayerId });
                        }
                        gameState.currentPlayerId = getNextPlayerId({ ...gameState, currentPlayerId: lastSkippedPlayerId });
                        gameState.log.push(`5„Çí${cardCount}ÊûöÂá∫„Åó„ÄÅ${skips}‰∫∫„Çπ„Ç≠„ÉÉ„ÉóÔºÅ`);
                    }

                    gameState.status = 'playing';
                    delete gameState.pendingAction;
                    transaction.update(roomRef, { gameState });
                });
                fiveSkipModal.classList.add('hidden');
            } catch (error) {
                 console.error("5„Çπ„Ç≠„ÉÉ„ÉóËß£Ê±∫„Ç®„É©„Éº:", error);
                 showMessage(error.message);
            }
        }

        function showDobonSuccessModal(gameState) {
            const { dobonInfo } = gameState || {};
            if (!dobonInfo) return;

            document.getElementById('dobon-player-info').textContent = `${dobonInfo.playerName}„ÅÆÊâãÊú≠ (ÂêàË®à: ${dobonInfo.sum})`;
            
            const handContainer = document.getElementById('dobon-hand-container');
            handContainer.innerHTML = '';
            dobonInfo.playerHand.forEach(card => handContainer.appendChild(createCardElement(card)));

            const fieldContainer = document.getElementById('dobon-field-container');
            fieldContainer.innerHTML = '';
            dobonInfo.fieldCards.forEach(card => fieldContainer.appendChild(createCardElement(card)));

            const continueBtn = document.getElementById('dobon-continue-btn');
            const waitMsg = document.getElementById('dobon-wait-message');

            if (currentUser.uid === dobonInfo.nextPlayerId) {
                continueBtn.classList.remove('hidden');
                waitMsg.classList.add('hidden');
            } else {
                continueBtn.classList.add('hidden');
                waitMsg.classList.remove('hidden');
            }

            dobonSuccessModal.classList.remove('hidden');
        }

        async function resumeAfterDobon() {
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("„É´„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ");
                    
                    let gameState = roomDoc.data().gameState;
                    if (gameState.status !== 'awaiting_dobon_acknowledgement') return;

                    gameState.currentPlayerId = gameState.dobonInfo.nextPlayerId;
                    gameState.field = { cards: [], lastPlayerId: null, suitLock: null };
                    gameState.log.push("Â†¥„ÅåÊµÅ„Çå„Åæ„Åô„ÄÇ");
                    delete gameState.dobonInfo;

                    const activePlayersCount = gameState.players.filter(p => !gameState.rankings.includes(p.id)).length;
                    if (activePlayersCount <= 1) {
                         const lastPlayer = gameState.players.find(p => !gameState.rankings.includes(p.id));
                        if(lastPlayer && !gameState.rankings.includes(lastPlayer.id)) {
                            gameState.rankings.push(lastPlayer.id);
                        }
                        gameState.status = 'finished';
                    } else {
                        gameState.status = 'playing';
                    }
                    
                    transaction.update(roomRef, { gameState });
                });
            } catch(error) {
                console.error("„Éâ„Éú„É≥Âæå„ÅÆÂÜçÈñã„Ç®„É©„Éº:", error);
                showMessage(error.message);
            }
        }

        async function prepareNextGame() {
            gameOverModal.classList.add('hidden');
            await startGame();
        }

        function promptJokerSuit() {
            const usedSuits = selectedCards
                .filter(c => c.suit !== 'JOKER')
                .map(c => c.suit);
            
            const suitButtons = document.querySelectorAll('#joker-suit-buttons .suit-button');
            suitButtons.forEach(button => {
                const suit = button.dataset.suit;
                button.disabled = usedSuits.includes(suit);
            });
            jokerSuitModal.classList.remove('hidden');
        }

        function handleJokerSuitSelection(chosenSuit) {
            jokerSuitModal.classList.add('hidden');
            const cardsToPlay = selectedCards.map(card => {
                if (card.suit === 'JOKER') {
                    return { ...card, designatedSuit: chosenSuit };
                }
                return card;
            });
            executePlay(cardsToPlay);
        }

        document.getElementById('create-room-btn').addEventListener('click', createRoom);
        document.getElementById('join-room-btn').addEventListener('click', joinRoom);
        document.getElementById('start-game-btn').addEventListener('click', startGame);
        document.getElementById('play-card-btn').addEventListener('click', playCards);
        document.getElementById('pass-btn').addEventListener('click', passTurn);
        document.getElementById('dobon-btn').addEventListener('click', declareDobon);
        document.getElementById('next-game-btn').addEventListener('click', prepareNextGame);
        document.getElementById('leave-room-btn').addEventListener('click', confirmAndLeave);
        leaveGameBtn.addEventListener('click', confirmAndLeave);
        
        document.getElementById('confirm-selection-btn').addEventListener('click', confirmSelection);
        document.getElementById('confirm-8giri-btn').addEventListener('click', resolve8giri);
        document.getElementById('confirm-5skip-btn').addEventListener('click', resolve5skip);
        document.getElementById('received-cards-ok-btn').addEventListener('click', () => {
            receivedCardsModal.classList.add('hidden');
        });
        document.getElementById('dobon-continue-btn').addEventListener('click', resumeAfterDobon);
        document.querySelectorAll('#joker-suit-buttons .suit-button').forEach(button => {
            button.addEventListener('click', () => handleJokerSuitSelection(button.dataset.suit));
        });
    </script>
</body>
</html>