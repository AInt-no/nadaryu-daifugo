<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>オンライン対戦 大富豪</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap');
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #f0f2f5;
        }
        .card {
            width: 80px;
            height: 120px;
            border: 1px solid #999;
            border-radius: 8px;
            background-color: white;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 4px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            user-select: none;
            position: relative;
            flex-shrink: 0;
        }
        .card.selected {
            transform: translateY(-20px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        .card.joker {
            background-color: #fde047;
        }
        .card .suit-top, .card .suit-bottom {
            font-size: 1.2rem;
            line-height: 1;
        }
        .card .suit-bottom {
            transform: rotate(180deg);
        }
        .card .number {
            font-size: 1.8rem;
            font-weight: bold;
            text-align: center;
        }
        .card.red { color: #ef4444; }
        .card.black { color: #1f2937; }
        
        .player-hand {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 10px 40px 20px 40px;
            min-height: 170px;
        }
        .player-hand .card {
            margin-left: -40px;
        }
        .player-hand .card:first-child {
            margin-left: 0;
        }
        .field-cards {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 140px;
            gap: 8px;
        }
        .player-info {
            transition: all 0.3s ease;
            transform: scale(1);
        }
        .player-info.current-turn {
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
            transform: scale(1.05);
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .selection-hand {
             display: flex;
             justify-content: center;
             flex-wrap: wrap;
             gap: 8px;
             margin-top: 1rem;
             margin-bottom: 1.5rem;
             max-height: 320px;
             overflow-y: auto;
             padding: 1rem;
             background-color: rgba(0,0,0,0.05);
             border-radius: 8px;
        }
        .selection-hand .card {
            margin-left: 0;
        }
        .selection-hand .card.selected {
             transform: translateY(-10px);
             border: 2px solid #3b82f6;
        }

        /* ===== 【新規追加】リロードボタン用のスタイル ===== */
        #reload-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 48px;
            height: 48px;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            font-size: 1.6rem;
            line-height: 1;
            cursor: pointer;
            z-index: 1100; /* モーダル(1000)より手前に表示 */
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
        }
        #reload-btn:hover {
            background-color: rgba(255, 255, 255, 0.4);
            transform: rotate(90deg);
        }
    </style>
</head>
<body class="bg-green-800 text-white">

    <div id="app" class="container mx-auto p-4 max-w-7xl">

        <button id="reload-btn" onclick="location.reload()" title="ページを更新">🔄</button>

        <div id="home-screen" class="text-center py-12">
            <h1 class="text-5xl font-bold mb-4 text-yellow-300">オンライン大富豪</h1>
            <p class="mb-8 text-lg">ルームを作成するか、IDを入力して参加してください。</p>
            
            <div class="max-w-md mx-auto bg-white/10 p-8 rounded-lg shadow-lg backdrop-blur-sm">
                <div class="mb-6">
                    <label for="player-name" class="block mb-2 text-sm font-bold">プレイヤー名</label>
                    <input type="text" id="player-name" class="w-full px-4 py-2 rounded-md text-gray-800" placeholder="名前を入力">
                </div>
                
                <button id="create-room-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-gray-800 font-bold py-3 px-4 rounded-lg text-lg transition duration-300 mb-4">
                    ルームを作成する
                </button>
                
                <div class="flex items-center">
                    <input type="text" id="room-id-input" class="w-full px-4 py-2 rounded-l-md text-gray-800" placeholder="ルームIDを入力">
                    <button id="join-room-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-r-lg transition duration-300">参加</button>
                </div>
            </div>
        </div>

        <div id="lobby-screen" class="hidden">
            <h2 class="text-3xl font-bold text-center mb-4">待機ルーム</h2>
            <div class="text-center mb-6">
                <p class="text-lg">ルームID: <span id="room-id-display" class="font-bold text-2xl text-yellow-300 bg-black/20 px-3 py-1 rounded-md cursor-pointer" onclick="copyRoomId()"></span></p>
                <p class="text-sm text-gray-300">（クリックしてIDをコピー）</p>
            </div>
            
            <div class="bg-white/10 p-6 rounded-lg shadow-lg">
                <h3 class="text-xl font-bold mb-4">参加プレイヤー</h3>
                <ul id="player-list" class="space-y-2">
                    </ul>
            </div>
            
            <div class="text-center mt-8">
                <button id="start-game-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-4 px-8 rounded-lg text-xl transition duration-300 shadow-lg disabled:bg-gray-500 disabled:cursor-not-allowed">
                    ゲーム開始 (2人以上で可能)
                </button>
            </div>
        </div>

        <div id="game-screen" class="hidden">
            <div id="other-players-container" class="flex justify-around mb-4">
                </div>

            <div class="bg-green-900/50 min-h-[220px] rounded-lg p-4 mb-4 border-2 border-yellow-400/50">
                <div class="text-center mb-2">
                    <p class="text-sm">場に出ているカード</p>
                    <div id="game-info" class="text-sm text-yellow-300 h-5"></div>
                </div>
                <div id="field" class="field-cards">
                    </div>
            </div>

            <div class="fixed bottom-0 left-0 right-0 bg-black/30 backdrop-blur-sm p-4">
                <div id="my-hand" class="player-hand mb-4">
                    </div>
                <div id="action-buttons" class="flex justify-center items-center gap-4">
                    <button id="play-card-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg text-lg transition duration-300 disabled:bg-gray-500">出す</button>
                    <button id="pass-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg text-lg transition duration-300 disabled:bg-gray-500">パス</button>
                    <button id="dobon-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg text-lg transition duration-300 disabled:bg-gray-500">ドボン！</button>
                </div>
            </div>
        </div>
        
        <div id="game-over-modal" class="hidden modal-overlay">
            <div class="modal-content bg-gray-800 text-white w-full max-w-md">
                <h2 id="game-over-title" class="text-3xl font-bold mb-4 text-yellow-300">ゲーム終了！</h2>
                <div id="rankings-list" class="text-left space-y-2 mb-6">
                    </div>
                <button id="next-game-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">次のゲームへ</button>
                <button id="leave-room-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded ml-2">ルームを抜ける</button>
            </div>
        </div>

        <div id="message-modal" class="hidden modal-overlay">
            <div id="message-content" class="modal-content bg-gray-800 text-white">
                </div>
        </div>

        <div id="selection-modal" class="hidden modal-overlay">
            <div class="modal-content bg-gray-800 text-white w-full max-w-2xl">
                <h2 id="selection-title" class="text-2xl font-bold mb-2"></h2>
                <p id="selection-description" class="mb-4"></p>
                <div id="selection-hand" class="selection-hand">
                    </div>
                <button id="confirm-selection-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg disabled:bg-gray-500 disabled:cursor-not-allowed">
                    決定
                </button>
            </div>
        </div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

        // =========================================================================
        // Firebase設定
        // =========================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyAduXdqwj7aeFAN9sHajCEsX0BDcUWHSv4",
            authDomain: "dai-fugo.firebaseapp.com",
            projectId: "dai-fugo",
            storageBucket: "dai-fugo.firebasestorage.app",
            messagingSenderId: "83747675254",
            appId: "1:83747675254:web:652d8bed0fe1ce045f5357",
            measurementId: "G-B1338R181P"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // =========================================================================
        // グローバル変数と定数
        // =========================================================================
        const appId = firebaseConfig.projectId;
        let currentUser = null;
        let currentRoomId = null;
        let unsubscribeRoom = null;
        let selectedCards = [];
        let cardsForSelection = [];
        let localGameState = {};

        const SUITS = ['S', 'H', 'D', 'C'];
        const NUMBERS = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1, 2];
        const JOKER = { suit: 'JOKER', number: 99, id: 'JOKER' };

        const homeScreen = document.getElementById('home-screen');
        const lobbyScreen = document.getElementById('lobby-screen');
        const gameScreen = document.getElementById('game-screen');
        const gameOverModal = document.getElementById('game-over-modal');
        const selectionModal = document.getElementById('selection-modal');

        // =========================================================================
        // 認証処理
        // =========================================================================
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                const savedRoomId = sessionStorage.getItem('daifugoRoomId');
                if (savedRoomId && !currentRoomId) {
                    await rejoinRoom(savedRoomId);
                }
            } else {
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("匿名認証エラー:", error);
                    showMessage("認証に失敗しました。ページをリロードしてください。");
                }
            }
        });

        // =========================================================================
        // 画面遷移
        // =========================================================================
        function showScreen(screen) {
            homeScreen.classList.add('hidden');
            lobbyScreen.classList.add('hidden');
            gameScreen.classList.add('hidden');
            screen.classList.remove('hidden');
        }

        // =========================================================================
        // UIヘルパー関数
        // =========================================================================
        function showMessage(message, duration = 3000) {
            const modal = document.getElementById('message-modal');
            const content = document.getElementById('message-content');
            content.textContent = message;
            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.add('hidden'), duration);
        }

        function copyRoomId() {
            const roomId = document.getElementById('room-id-display').textContent;
            navigator.clipboard.writeText(roomId).then(() => {
                showMessage('ルームIDをコピーしました！');
            }, (err) => {
                showMessage('コピーに失敗しました。');
            });
        }

        // =========================================================================
        // ルーム管理
        // =========================================================================
        async function createRoom() {
            if (!currentUser) {
                showMessage("認証情報が取得できません。");
                return;
            }
            const playerName = document.getElementById('player-name').value.trim() || `プレイヤー${Math.floor(Math.random() * 1000)}`;
            const roomId = Math.random().toString(36).substring(2, 7).toUpperCase();
            
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, roomId);
            const newRoom = {
                roomId: roomId,
                hostId: currentUser.uid,
                players: [{ id: currentUser.uid, name: playerName, isReady: false, rank: null, cardCount: 0 }],
                gameState: { status: 'waiting' },
                createdAt: new Date()
            };

            try {
                await setDoc(roomRef, newRoom);
                currentRoomId = roomId;
                sessionStorage.setItem('daifugoRoomId', roomId);
                listenToRoomChanges(roomId);
            } catch (error) {
                console.error("ルーム作成エラー:", error);
                showMessage("ルームの作成に失敗しました。");
            }
        }

        async function joinRoom() {
            if (!currentUser) {
                showMessage("認証情報が取得できません。");
                return;
            }
            const roomId = document.getElementById('room-id-input').value.trim().toUpperCase();
            if (!roomId) {
                showMessage("ルームIDを入力してください。");
                return;
            }
            const playerName = document.getElementById('player-name').value.trim() || `プレイヤー${Math.floor(Math.random() * 1000)}`;
            
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, roomId);

            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("ルームが見つかりません。");
                    
                    const roomData = roomDoc.data();
                    if (roomData.gameState.status !== 'waiting') throw new Error("ゲームは既に開始されています。");

                    if (!roomData.players.find(p => p.id === currentUser.uid)) {
                        if (roomData.players.length >= 4) throw new Error("このルームは満員です。");
                        const newPlayer = { id: currentUser.uid, name: playerName, isReady: false, rank: null, cardCount: 0 };
                        transaction.update(roomRef, { players: [...roomData.players, newPlayer] });
                    }
                });
                currentRoomId = roomId;
                sessionStorage.setItem('daifugoRoomId', roomId);
                listenToRoomChanges(roomId);
            } catch (error) {
                console.error("ルーム参加エラー:", error);
                showMessage(error.message);
                currentRoomId = null;
            }
        }

        async function rejoinRoom(roomId) {
            console.log(`ルーム ${roomId} に再接続します。`);
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, roomId);
            try {
                const roomDoc = await getDoc(roomRef);
                if (!roomDoc.exists() || !roomDoc.data().players.some(p => p.id === currentUser.uid)) {
                    console.log("ルームが存在しないか、あなたはプレイヤーではありません。ホームに戻ります。");
                    sessionStorage.removeItem('daifugoRoomId');
                    showScreen(homeScreen);
                    return;
                }
                currentRoomId = roomId;
                listenToRoomChanges(roomId);
            } catch (error) {
                console.error("再接続エラー:", error);
                sessionStorage.removeItem('daifugoRoomId');
                showScreen(homeScreen);
            }
        }
        
        async function leaveRoom() {
            sessionStorage.removeItem('daifugoRoomId');
            const roomId = currentRoomId;
            
            if (unsubscribeRoom) unsubscribeRoom();
            unsubscribeRoom = null;
            currentRoomId = null;
            localGameState = {};
            showScreen(homeScreen);

            if (!roomId || !currentUser) return;

            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, roomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) return;
                    const roomData = roomDoc.data();
                    const updatedPlayers = roomData.players.filter(p => p.id !== currentUser.uid);

                    if (updatedPlayers.length === 0) {
                        transaction.delete(roomRef);
                    } else {
                        if (roomData.hostId === currentUser.uid) {
                            transaction.update(roomRef, { players: updatedPlayers, hostId: updatedPlayers[0].id });
                        } else {
                            transaction.update(roomRef, { players: updatedPlayers });
                        }
                    }
                });
            } catch (error) {
                console.error("ルーム退出エラー:", error);
            }
        }

        // =========================================================================
        // ゲームロジック
        // =========================================================================
        function createDeck() {
            const deck = [];
            SUITS.forEach(suit => {
                NUMBERS.forEach(number => {
                    deck.push({ suit, number, id: `${suit}${number}` });
                });
            });
            deck.push({ ...JOKER, id: 'JOKER1' });
            deck.push({ ...JOKER, id: 'JOKER2' });
            return deck;
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        async function startGame() {
            if (!currentRoomId) return;
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            const roomDoc = await getDoc(roomRef);
            if (!roomDoc.exists()) return;

            const roomData = roomDoc.data();
            const players = roomData.players;
            if (players.length < 2) {
                showMessage("プレイヤーが2人以上必要です。"); return;
            }
            
            const deck = shuffle(createDeck());
            const hands = {};
            players.forEach(p => { hands[p.id] = []; });

            let playerIndex = 0;
            deck.forEach(card => {
                hands[players[playerIndex].id].push(card);
                playerIndex = (playerIndex + 1) % players.length;
            });
            
            Object.keys(hands).forEach(playerId => {
                hands[playerId].sort((a, b) => getCardStrength(a) - getCardStrength(b));
            });

            const playOrder = players.map(p => p.id);
            let currentPlayerId;
            const lastGameWinner = players.find(p => p.rank === players.length);
            if (lastGameWinner) {
                currentPlayerId = lastGameWinner.id;
            } else {
                const diamond3Player = Object.keys(hands).find(id => hands[id].some(c => c.suit === 'D' && c.number === 3));
                currentPlayerId = diamond3Player || players[0].id;
            }
            
            const updatedPlayers = players.map(p => ({ ...p, cardCount: hands[p.id].length, rank: null }));

            const initialGameState = {
                status: 'playing',
                hands: hands,
                players: updatedPlayers,
                playOrder: playOrder,
                currentPlayerId: currentPlayerId,
                field: { cards: [], lastPlayerId: null, suitLock: null },
                passCount: 0,
                isRevolution: false,
                isElevenBack: false,
                lastActionTimestamp: new Date(),
                rankings: [],
                log: [`ゲーム開始！ ${players.find(p=>p.id === currentPlayerId).name}さんからスタートです。`]
            };

            await updateDoc(roomRef, { gameState: initialGameState, players: updatedPlayers });
        }
        
        async function playCards() {
            if (selectedCards.length === 0) return;
            
            const { hands, currentPlayerId, field, isRevolution, isElevenBack } = localGameState;
            if (currentUser.uid !== currentPlayerId) {
                showMessage("あなたのターンではありません。"); return;
            }
            
            const validation = isValidPlay(selectedCards, field, isRevolution, isElevenBack);
            if (!validation.valid) {
                showMessage(validation.message); return;
            }

            const myHand = hands[currentUser.uid];
            if (myHand.length === selectedCards.length) {
                const lastCard = selectedCards.find(c => c.suit !== 'JOKER') || selectedCards[0];
                const strongestCardNumber = isRevolution ? 3 : 2;
                if (lastCard.suit === 'JOKER' || lastCard.number === strongestCardNumber) {
                    showMessage("反則あがりです！ジョーカーや最強のカード(2または3)ではあがれません。"); return;
                }
            }

            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("ルームデータが見つかりません。");
                    
                    let newGameState = { ...roomDoc.data().gameState };
                    if (newGameState.currentPlayerId !== currentUser.uid) throw new Error("ターンが変わっています。");

                    const newHand = newGameState.hands[currentUser.uid].filter(card => !selectedCards.find(sc => sc.id === card.id));
                    newGameState.hands[currentUser.uid] = newHand;
                    
                    let updatedPlayers = newGameState.players.map(p => p.id === currentUser.uid ? { ...p, cardCount: newHand.length } : p);
                    
                    const playedCardNumber = (selectedCards.find(c => c.suit !== 'JOKER') || selectedCards[0]).number;
                    const playedCardCount = selectedCards.length;
                    const player = newGameState.players.find(p => p.id === currentUser.uid);

                    let isFinished = false;
                    if (newHand.length === 0) {
                        isFinished = true;
                        newGameState.rankings.push(currentUser.uid);
                        newGameState.log.push(`${player.name}さんがあがりました！`);
                    }

                    if (!isFinished && (playedCardNumber === 7 || playedCardNumber === 10)) {
                        newGameState.status = 'awaiting_selection';
                        newGameState.pendingAction = {
                            type: playedCardNumber === 7 ? '7-pass' : '10-discard',
                            playerId: currentUser.uid,
                            count: playedCardCount
                        };
                        newGameState.field = { cards: selectedCards, lastPlayerId: currentUser.uid, suitLock: validation.newSuitLock };
                        newGameState.passCount = 0;
                        newGameState.log.push(`${player.name}さんが${playedCardNumber}を${playedCardCount}枚出しました。`);
                    } else {
                        const effectResult = handleSpecialCards(selectedCards, newGameState);
                        newGameState = effectResult.newGameState;
                        
                        if (!effectResult.fieldCleared) {
                           newGameState.field = { cards: selectedCards, lastPlayerId: currentUser.uid, suitLock: validation.newSuitLock };
                           newGameState.passCount = 0;
                           if (!isFinished && !effectResult.skipTurn) {
                               newGameState.currentPlayerId = getNextPlayerId(newGameState);
                           }
                        } else {
                            newGameState.field = { cards: [], lastPlayerId: null, suitLock: null };
                            newGameState.passCount = 0;
                            if (!isFinished) newGameState.currentPlayerId = currentUser.uid;
                            else newGameState.currentPlayerId = getNextPlayerId(newGameState);
                        }
                        
                        if (effectResult.fieldCleared && newGameState.isElevenBack) {
                            newGameState.isElevenBack = false;
                            newGameState.log.push("イレブンバックの効果が切れました。");
                        }
                    }
                    
                    newGameState.players = updatedPlayers;
                    newGameState.lastActionTimestamp = new Date();
                    
                    const activePlayersCount = newGameState.players.filter(p => !newGameState.rankings.includes(p.id)).length;
                    if (activePlayersCount <= 1) {
                        const lastPlayer = newGameState.players.find(p => !newGameState.rankings.includes(p.id));
                        if(lastPlayer && !newGameState.rankings.includes(lastPlayer.id)) {
                            newGameState.rankings.push(lastPlayer.id);
                        }
                        newGameState.status = 'finished';
                    }

                    transaction.update(roomRef, { gameState: newGameState });
                });
                selectedCards = [];
            } catch (error) {
                console.error("カード提出エラー:", error);
                showMessage(error.message);
            }
        }
        
        async function passTurn() {
             const { currentPlayerId } = localGameState;
            if (currentUser.uid !== currentPlayerId) {
                showMessage("あなたのターンではありません。"); return;
            }

            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("ルームデータが見つかりません。");
                    
                    let gameState = roomDoc.data().gameState;
                    if (gameState.currentPlayerId !== currentUser.uid) throw new Error("ターンが変わっています。");
                    
                    gameState.passCount += 1;
                    const activePlayersCount = gameState.players.filter(p => p.cardCount > 0 && !gameState.rankings.includes(p.id)).length;

                    if (gameState.passCount >= activePlayersCount - 1 && gameState.field.lastPlayerId) {
                        gameState.currentPlayerId = gameState.field.lastPlayerId;
                        gameState.field = { cards: [], lastPlayerId: null, suitLock: null };
                        gameState.passCount = 0;
                        gameState.log.push("場が流れました。");
                        if (gameState.isElevenBack) {
                            gameState.isElevenBack = false;
                            gameState.log.push("イレブンバックの効果が切れました。");
                        }
                    } else {
                        gameState.currentPlayerId = getNextPlayerId(gameState);
                    }
                    
                    gameState.lastActionTimestamp = new Date();
                    transaction.update(roomRef, { gameState });
                });
            } catch (error) {
                console.error("パスエラー:", error);
                showMessage(error.message);
            }
        }

        function handleSpecialCards(playedCards, gameState) {
            const cardNum = (playedCards.find(c => c.suit !== 'JOKER') || playedCards[0]).number;
            const cardCount = playedCards.length;
            let fieldCleared = false;
            let skipTurn = false;
            const player = gameState.players.find(p => p.id === gameState.currentPlayerId);
            
            if (cardCount === 4 || (cardNum === 3 && cardCount === 3)) {
                gameState.isRevolution = !gameState.isRevolution;
                gameState.log.push(`${player.name}さんが革命を起こしました！`);
            }
            if (cardNum === 11 && cardCount % 2 !== 0) {
                gameState.isElevenBack = !gameState.isElevenBack;
                gameState.log.push(`${player.name}さんがイレブンバック！`);
            }
            
            switch (cardNum) {
                case 5:
                    const activePlayersCount = gameState.players.filter(p => !gameState.rankings.includes(p.id)).length;
                    if (cardCount >= activePlayersCount - 1) {
                        fieldCleared = true;
                        gameState.log.push(`${player.name}さんの5で他の全員がスキップされ、場が流れました。`);
                    } else {
                        let tempCurrentPlayerId = gameState.currentPlayerId;
                        for (let i = 0; i < cardCount; i++) {
                            tempCurrentPlayerId = getNextPlayerId({ ...gameState, currentPlayerId: tempCurrentPlayerId });
                        }
                        gameState.currentPlayerId = tempCurrentPlayerId;
                        skipTurn = true;
                        gameState.log.push(`${player.name}さんが5を出し、${cardCount}人スキップ！`);
                    }
                    break;
                case 8:
                    fieldCleared = true;
                    gameState.log.push(`${player.name}さんの8切り！`);
                    break;
            }
            return { newGameState: gameState, fieldCleared, skipTurn };
        }

        // =========================================================================
        // ヘルパー関数 (ロジック系)
        // =========================================================================
        function getCardStrength(card, isRevolution = false, isElevenBack = false) {
            if (card.suit === 'JOKER') return 999;
            const revolutionActive = isRevolution !== isElevenBack;
            let strength = card.number;
            if (strength === 1) strength = 14;
            if (strength === 2) strength = 15;
            if (revolutionActive) {
                if (strength === 3) return 16;
                return 15 - (strength - 3);
            }
            return strength;
        }
        
        function getNextPlayerId(gameState) {
            const { playOrder, currentPlayerId, rankings } = gameState;
            let currentIndex = playOrder.indexOf(currentPlayerId);
            if (currentIndex === -1) return playOrder.find(pId => !rankings.includes(pId));
            let nextPlayerId;
            do {
                currentIndex = (currentIndex + 1) % playOrder.length;
                nextPlayerId = playOrder[currentIndex];
            } while (rankings.includes(nextPlayerId));
            return nextPlayerId;
        }

        function isValidPlay(playedCards, field, isRevolution, isElevenBack) {
            if (playedCards.length === 0) return { valid: false, message: "カードを選択してください。" };

            const playIsJoker = playedCards.length === 1 && playedCards[0].suit === 'JOKER';
            const playIsSpade3 = playedCards.length === 1 && playedCards[0].suit === 'S' && playedCards[0].number === 3;
            const fieldIsJoker = field.cards.length === 1 && field.cards[0].suit === 'JOKER';
            
            if (fieldIsJoker && playIsSpade3) return { valid: true, newSuitLock: null };
            
            if (field.cards.length > 0) {
                if (playedCards.length !== field.cards.length) {
                    if (!playIsJoker) {
                        return { valid: false, message: "場と同じ枚数のカードを出してください。" };
                    }
                }
                
                const playStrength = getCardStrength(playedCards.find(c => c.suit !== 'JOKER') || playedCards[0], isRevolution, isElevenBack);
                const fieldStrength = getCardStrength(field.cards.find(c => c.suit !== 'JOKER') || field.cards[0], isRevolution, isElevenBack);
                
                if (playStrength <= fieldStrength) return { valid: false, message: "場よりも強いカードを出してください。" };
                
                if (field.suitLock) {
                    const playSuits = playedCards.map(c => c.suit).filter(s => s !== 'JOKER').sort().join('');
                    if (playSuits && field.suitLock !== playSuits) return { valid: false, message: `縛りが発生しています！スート: [${field.suitLock.split('').join(', ')}]` };
                }
            }
            
            const numbers = playedCards.map(c => c.number).filter(n => n !== 99);
            if ([...new Set(numbers)].length > 1) return { valid: false, message: "同じ数字のカードしか同時に出せません。" };

            let newSuitLock = null;
            if (field.cards.length > 0 && playedCards.length > 1) {
                const lastSuits = field.cards.map(c => c.suit).filter(s => s !== 'JOKER').sort().join('');
                const playSuits = playedCards.map(c => c.suit).filter(s => s !== 'JOKER').sort().join('');
                if (lastSuits === playSuits && playSuits.length > 0) newSuitLock = playSuits;
            }

            return { valid: true, newSuitLock };
        }

        // =========================================================================
        // Firestoreリスナー
        // =========================================================================
        function listenToRoomChanges(roomId) {
            if (unsubscribeRoom) unsubscribeRoom();

            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, roomId);
            unsubscribeRoom = onSnapshot(roomRef, (doc) => {
                if (!doc.exists()) {
                    showMessage("ルームが削除されました。ホームに戻ります。");
                    leaveRoom();
                    return;
                }
                
                const roomData = doc.data();
                localGameState = roomData.gameState;
                
                switch (localGameState.status) {
                    case 'waiting':
                        showScreen(lobbyScreen);
                        updateLobbyUI(roomData);
                        break;
                    
                    case 'playing':
                        if(selectionModal.classList.contains('hidden')) {
                             showScreen(gameScreen);
                             updateGameUI(localGameState);
                        }
                        break;
                        
                    case 'awaiting_selection':
                        showScreen(gameScreen);
                        updateGameUI(localGameState);
                        if (localGameState.pendingAction.playerId === currentUser.uid) {
                            showSelectionModal(localGameState);
                        }
                        break;
                        
                    case 'finished':
                        showScreen(gameScreen);
                        updateGameUI(localGameState);
                        showGameOverUI(localGameState);
                        break;
                }
            });
        }
        
        // =========================================================================
        // UI更新
        // =========================================================================
        function updateLobbyUI(roomData) {
            document.getElementById('room-id-display').textContent = roomData.roomId;
            const playerList = document.getElementById('player-list');
            playerList.innerHTML = '';
            roomData.players.forEach(player => {
                const li = document.createElement('li');
                li.className = 'bg-white/20 p-3 rounded-md flex justify-between items-center';
                li.textContent = player.name + (player.id === roomData.hostId ? ' (ホスト)' : '');
                playerList.appendChild(li);
            });

            const startGameBtn = document.getElementById('start-game-btn');
            if (currentUser && currentUser.uid === roomData.hostId) {
                startGameBtn.disabled = roomData.players.length < 2;
                startGameBtn.classList.remove('hidden');
            } else {
                startGameBtn.classList.add('hidden');
            }
        }

        function updateGameUI(gameState) {
            const { players, hands, currentPlayerId, field, isRevolution, isElevenBack, rankings } = gameState;
            
            const myHandContainer = document.getElementById('my-hand');
            myHandContainer.innerHTML = '';
            const myHand = (hands && currentUser && hands[currentUser.uid]) ? hands[currentUser.uid] : [];
            
            myHand.sort((a,b) => getCardStrength(a, isRevolution, isElevenBack) - getCardStrength(b, isRevolution, isElevenBack));
            myHand.forEach(card => {
                const cardEl = createCardElement(card);
                cardEl.addEventListener('click', () => toggleCardSelection(card, cardEl));
                if (selectedCards.some(sc => sc.id === card.id)) cardEl.classList.add('selected');
                myHandContainer.appendChild(cardEl);
            });
            
            const otherPlayersContainer = document.getElementById('other-players-container');
            otherPlayersContainer.innerHTML = '';
            const myPlayerIndex = players.findIndex(p => currentUser && p.id === currentUser.uid);
            if (myPlayerIndex === -1) return; // 自分がプレイヤーでない場合は描画を中断

            const orderedPlayers = [...players.slice(myPlayerIndex + 1), ...players.slice(0, myPlayerIndex)];
            
            orderedPlayers.forEach(player => {
                const playerInfoEl = document.createElement('div');
                playerInfoEl.className = 'player-info bg-black/30 p-3 rounded-lg text-center w-40';
                if (player.id === currentPlayerId) playerInfoEl.classList.add('current-turn');
                
                const rank = rankings.indexOf(player.id);
                const rankText = rank !== -1 ? `<span class="text-yellow-400 font-bold">${rank + 1}位</span>` : '';
                playerInfoEl.innerHTML = `<p class="font-bold truncate">${player.name}</p><p>残り: ${player.cardCount}枚</p><p>${rankText}</p>`;
                otherPlayersContainer.appendChild(playerInfoEl);
            });

            const fieldContainer = document.getElementById('field');
            fieldContainer.innerHTML = '';
            (field.cards || []).forEach(card => fieldContainer.appendChild(createCardElement(card)));
            if (!field.cards || field.cards.length === 0) fieldContainer.innerHTML = `<p class="text-gray-400">カードが出されていません</p>`;

            const gameInfoEl = document.getElementById('game-info');
            let infoText = '';
            if (isRevolution) infoText += '<span class="text-red-500 font-bold">革命中</span> ';
            if (isElevenBack) infoText += '<span class="text-blue-400 font-bold">イレブンバック中</span> ';
            if (field.suitLock) infoText += `<span class="text-green-400 font-bold">縛り: ${field.suitLock.split('').join(', ')}</span>`;
            gameInfoEl.innerHTML = infoText;

            const isMyTurn = currentPlayerId === currentUser.uid && gameState.status === 'playing';
            document.getElementById('play-card-btn').disabled = !isMyTurn;
            document.getElementById('pass-btn').disabled = !isMyTurn || !field.cards || field.cards.length === 0;
            document.getElementById('dobon-btn').disabled = !myHand || myHand.length < 2 || field.lastPlayerId === currentUser.uid || !field.cards || field.cards.length === 0;
        }
        
        function showGameOverUI(gameState) {
            gameOverModal.classList.remove('hidden');
            const rankingsList = document.getElementById('rankings-list');
            rankingsList.innerHTML = '';
            const rankNames = ['大富豪', '富豪', '貧民', '大貧民'];
            
            gameState.rankings.forEach((playerId, index) => {
                const player = gameState.players.find(p => p.id === playerId);
                const li = document.createElement('div');
                li.className = "flex justify-between items-center p-2 bg-white/10 rounded";
                const rankName = rankNames[index] || `${index + 1}位`;
                li.innerHTML = `<span class="font-bold text-yellow-400">${rankName}</span><span>${player.name}</span>`;
                rankingsList.appendChild(li);
            });
            
            const host = localGameState.players.find(p => p.id === localGameState.hostId);
            document.getElementById('next-game-btn').classList.toggle('hidden', currentUser.uid !== host?.id);
        }
        
        function createCardElement(card) {
            const el = document.createElement('div');
            el.className = 'card';
            
            if (card.suit === 'JOKER') {
                el.classList.add('joker');
                el.innerHTML = `<div class="suit-top">🃏</div><div class="number">JOKER</div><div class="suit-bottom">🃏</div>`;
            } else {
                const suitSymbols = { S: '♠', H: '♥', D: '♦', C: '♣' };
                const suitColors = { S: 'black', H: 'red', D: 'red', C: 'black' };
                const numberDisplay = { 1: 'A', 11: 'J', 12: 'Q', 13: 'K' };
                el.classList.add(suitColors[card.suit]);
                el.innerHTML = `<div class="suit-top">${suitSymbols[card.suit]}</div><div class="number">${numberDisplay[card.number] || card.number}</div><div class="suit-bottom">${suitSymbols[card.suit]}</div>`;
            }
            return el;
        }
        
        function toggleCardSelection(card, element) {
            const index = selectedCards.findIndex(c => c.id === card.id);
            if (index > -1) {
                selectedCards.splice(index, 1);
                element.classList.remove('selected');
            } else {
                selectedCards.push(card);
                element.classList.add('selected');
            }
        }

        // =========================================================================
        // 7渡し/10捨て用のUIとロジック
        // =========================================================================
        function showSelectionModal(gameState) {
            const { pendingAction, hands } = gameState;
            if (!pendingAction || selectionModal.classList.contains('hidden') === false) return;

            const myHand = hands[currentUser.uid];
            cardsForSelection = [];

            const titleEl = document.getElementById('selection-title');
            const descriptionEl = document.getElementById('selection-description');
            const handContainer = document.getElementById('selection-hand');
            const confirmBtn = document.getElementById('confirm-selection-btn');
            
            titleEl.textContent = pendingAction.type === '7-pass' ? '7渡し' : '10捨て';
            descriptionEl.textContent = `手札から${pendingAction.type === '7-pass' ? '渡す' : '捨てる'}カードを ${pendingAction.count}枚 選んでください。`;
            
            handContainer.innerHTML = '';
            myHand.forEach(card => {
                const cardEl = createCardElement(card);
                cardEl.addEventListener('click', () => toggleCardForSelection(card, cardEl, pendingAction.count));
                handContainer.appendChild(cardEl);
            });
            
            confirmBtn.disabled = true;
            selectionModal.classList.remove('hidden');
        }

        function toggleCardForSelection(card, element, maxSelection) {
            const confirmBtn = document.getElementById('confirm-selection-btn');
            const index = cardsForSelection.findIndex(c => c.id === card.id);
            if (index > -1) {
                cardsForSelection.splice(index, 1);
                element.classList.remove('selected');
            } else {
                if (cardsForSelection.length < maxSelection) {
                    cardsForSelection.push(card);
                    element.classList.add('selected');
                }
            }
            confirmBtn.disabled = cardsForSelection.length !== maxSelection;
        }

        async function confirmSelection() {
            const roomRef = doc(db, `artifacts/${appId}/public/data/daifugo-rooms`, currentRoomId);
            try {
                 await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("ルームが見つかりません。");

                    let gameState = roomDoc.data().gameState;
                    const { pendingAction, hands, players } = gameState;

                    if (!pendingAction || pendingAction.playerId !== currentUser.uid) throw new Error("不正な操作です。");
                    if (cardsForSelection.length !== pendingAction.count) throw new Error(`カードを${pendingAction.count}枚選択してください。`);

                    const player = players.find(p => p.id === currentUser.uid);
                    let myNewHand = hands[currentUser.uid].filter(card => !cardsForSelection.find(sc => sc.id === card.id));

                    if (pendingAction.type === '7-pass') {
                        const nextPlayerId = getNextPlayerId(gameState);
                        const nextPlayer = players.find(p => p.id === nextPlayerId);
                        hands[nextPlayerId].push(...cardsForSelection);
                        hands[nextPlayerId].sort((a,b) => getCardStrength(a, gameState.isRevolution, gameState.isElevenBack));
                        gameState.log.push(`${player.name}さんが${nextPlayer.name}さんにカードを${pendingAction.count}枚渡しました。`);
                    } else {
                        gameState.log.push(`${player.name}さんがカードを${pendingAction.count}枚捨てました。`);
                    }

                    hands[currentUser.uid] = myNewHand;
                    
                    gameState.players = players.map(p => ({...p, cardCount: hands[p.id].length }));
                    gameState.status = 'playing';
                    gameState.currentPlayerId = getNextPlayerId(gameState);
                    delete gameState.pendingAction;

                    transaction.update(roomRef, { gameState });
                 });
                 selectionModal.classList.add('hidden');
                 cardsForSelection = [];

            } catch(error) {
                console.error("選択確定エラー:", error);
                showMessage(error.message);
            }
        }
        
        async function prepareNextGame() {
            gameOverModal.classList.add('hidden');
            await startGame();
        }

        // =========================================================================
        // イベントリスナー
        // =========================================================================
        window.addEventListener('DOMContentLoaded', () => {
            //
        });

        document.getElementById('create-room-btn').addEventListener('click', createRoom);
        document.getElementById('join-room-btn').addEventListener('click', joinRoom);
        document.getElementById('start-game-btn').addEventListener('click', startGame);
        document.getElementById('play-card-btn').addEventListener('click', playCards);
        document.getElementById('pass-btn').addEventListener('click', passTurn);
        document.getElementById('dobon-btn').addEventListener('click', () => showMessage("ドボン機能は現在調整中です。"));
        document.getElementById('next-game-btn').addEventListener('click', prepareNextGame);
        document.getElementById('leave-room-btn').addEventListener('click', leaveRoom);
        document.getElementById('confirm-selection-btn').addEventListener('click', confirmSelection);
    </script>
</body>
</html>
